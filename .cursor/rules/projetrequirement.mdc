---
description:

# 🎯 Goal

Build an ultra‑intuitive booking/catalog SaaS for automotive detailers. Pros create a shop, add services, set availability, and get a public booking URL. Clients pick vehicle size → category → service(s)/formula(s)/add‑ons → slot → contact details (and optionally pay later phase).

---

## ✅ In‑Scope (MVP • as of 27 Sep 2025)

* Single vendor (each shop operates independently under its own public URL)
* Shop profile (images x1–4, address and/or service zones, hours, lead times)
* Vehicle sizes (name, short description, optional image)
* Service categories (name, optional image)
* Services (name, description, base price, base duration, images x1–4)
* Service formulas (per‑service bundles with additive price/duration + feature bullet points)
* Per‑vehicle‑size price/duration modifiers for each service
* Add‑ons (per‑service optional extras with price/duration)
* Booking flow (availability, slot pick, contact + vehicle refs)
* No payments in MVP (but model extensible)

## ❌ Out‑of‑Scope (MVP)

* Multi‑staff / resource optimization, multi‑location assignment
* Online payments, refunds, deposits, taxes/VAT calculations
* Recurring bookings, subscriptions
* Complex driving‑time routing between zones

---

# Product Requirements (PRD)

## 1) User Types

* **Detailer (Shop Owner)**: CRUD shop, sizes, categories, services, formulas, add‑ons, availability, lead time. View bookings.
* **Client (End User)**: Discover public shop page, configure services, pick slot, submit booking request.
* **Admin (Platform)**: Soft‑delete abusive shops, observe metrics. (Minimal for MVP.)

## 2) Core Concepts

* **Shop** has: identity, images, one physical address *and/or* one+ service zones (city + radius km), business hours by weekday, **min notice** (hours/days), **weekly advance notice** (number of weeks allowed ahead), supported **vehicle sizes**.
* **Category** groups services (e.g., Interior, Exterior, Full Valet).
* **Service**: base price/duration + images + rich description.
* **Formula** (aka package/tier on a service): additive price & duration deltas, checklist features.
* **Per‑Size Modifiers**: for each service, optional price/duration deltas per vehicle size.
* **Add‑ons**: per service, independent extras with price/duration deltas.
* **Availability** = opening windows per weekday + blackout dates + algorithm to propose bookable slots after min notice & within weekly advance limit, respecting current confirmed bookings.

## 3) Booking Flow (Client)

1. (Conditional) Pick **vehicle size** (if the shop defined any).
2. Pick **category**, then one or more **services** within it.
3. For each selected service: choose **formula** (optional), **add‑ons** (optional).
4. System computes **total price & total duration** for all selected services.
5. Pick **date & time** among available slots (respecting min notice, hours, existing bookings).
6. Enter **contact info** + **vehicle reference** (make/model/plate optional), additional notes.
7. Create **Pending** booking (status) → Shop receives notification.

> Statuses: `pending` → `confirmed` | `declined` | `cancelled_by_client` | `cancelled_by_shop`.

## 4) Availability Rules

* Opening hours = one or multiple **timeframes per weekday**.
* Slot granularity: 15 min (config constant), service durations in minutes.
* Compute rolling availability for next `advance_weeks` weeks, excluding past times and applying `min_notice`.
* Occupancy model: single parallel job (one car at a time) for MVP. (Extensible to capacity later.)

---

# Tech & Project Guardrails (Cursor‑Friendly)

* **Language**: TypeScript (strict).
* **Runtime**: Next.js (App Router) or Expo Router (if mobile first). Default to **Next.js** for MVP.
* **DB**: Supabase Postgres; Row Level Security (RLS) on per‑shop rows.
* **Auth**: Supabase Auth (email/password, magic link). Shops own their data.
* **APIs**: Next.js route handlers `/api/*` (Edge‑compatible where possible). JSON only.
* **Infra**: Vercel preview deploys; GitHub MCP for issues/PRs; Supabase MCP for migrations.
* **UI**: React + Tailwind + shadcn/ui; Lucide icons; Zod validation; React‑Hook‑Form.
* **Time**: `luxon` for TZ; store all timestamps in UTC; shop has a TZ field.
* **Testing**: Vitest + Playwright (critical flows: pricing calc + slot generation + booking).

---

# Data Model (ERD Sketch)

* **shops** (1) — (n) **service_categories**
* **shops** (1) — (n) **vehicle_sizes**
* **shops** (1) — (n) **services** — (n) **service_images**
* **services** (1) — (n) **service_formulas** — (n) **formula_features**
* **services** (1) — (n) **service_size_modifiers** (join to vehicle_sizes)
* **services** (1) — (n) **service_addons**
* **shops** (1) — (n) **opening_hours**
* **shops** (1) — (n) **service_zones**
* **shops** (1) — (n) **blackout_dates**
* **shops** (1) — (n) **bookings** — (n) **booking_items** (captures chosen services, formulas, add‑ons, size)

## TypeScript Types (source of truth)

```ts
type UUID = string;

export type MoneyCents = number; // store in cents

export interface Shop {
  id: UUID;
  ownerUserId: UUID;
  name: string;
  slug: string; // for public URL
  description?: string;
  images: string[]; // 1–4 URLs
  timezone: string; // IANA
  address?: {
    line1?: string; line2?: string; city?: string; postalCode?: string; country?: string;
    lat?: number; lon?: number;
  };
  minNoticeHours: number; // e.g., 4, 24, 48
  advanceWeeks: number;   // how far ahead clients can book
  createdAt: string; updatedAt: string;
}

export interface ServiceZone { id: UUID; shopId: UUID; city: string; radiusKm: number; }

export interface OpeningHour {
  id: UUID; shopId: UUID; weekday: 0|1|2|3|4|5|6; // 0=Sunday
  frames: Array<{ start: string; end: string }>; // HH:mm in shop timezone
}

export interface VehicleSize { id: UUID; shopId: UUID; name: string; blurb?: string; image?: string; order: number; }

export interface ServiceCategory { id: UUID; shopId: UUID; name: string; image?: string; order: number; }

export interface Service {
  id: UUID; shopId: UUID; categoryId: UUID;
  name: string; description?: string;
  basePrice: MoneyCents; baseDurationMin: number;
  images: string[]; order: number; isActive: boolean;
}

export interface ServiceFormula {
  id: UUID; serviceId: UUID; name: string;
  addPrice: MoneyCents; addDurationMin: number;
  features: string[]; order: number; isActive: boolean;
}

export interface ServiceSizeModifier {
  id: UUID; serviceId: UUID; vehicleSizeId: UUID;
  addPrice: MoneyCents; addDurationMin: number;
}

export interface ServiceAddon {
  id: UUID; serviceId: UUID; name: string;
  addPrice: MoneyCents; addDurationMin: number; description?: string; order: number; isActive: boolean;
}

export type BookingStatus = "pending"|"confirmed"|"declined"|"cancelled_by_client"|"cancelled_by_shop";

export interface Booking {
  id: UUID; shopId: UUID; status: BookingStatus;
  slotStart: string; // ISO UTC
  slotEnd: string;   // ISO UTC
  client:
    { firstName: string; lastName: string; phone?: string; email?: string };
  vehicle?: { make?: string; model?: string; plate?: string; notes?: string; sizeId?: UUID };
  createdAt: string; updatedAt: string;
}

export interface BookingItem {
  id: UUID; bookingId: UUID; serviceId: UUID;
  formulaId?: UUID; sizeId?: UUID; // lock the size used for price calc
  addonIds: UUID[];
  // denormalized totals for audit
  unitPrice: MoneyCents; durationMin: number; // resolved per item
}
```

## Supabase SQL (migrations outline)

```sql
-- shops
create table shops (
  id uuid primary key default gen_random_uuid(),
  owner_user_id uuid not null,
  name text not null,
  slug text unique not null,
  description text,
  images text[] not null check (cardinality(images) between 1 and 4),
  timezone text not null,
  address jsonb,
  min_notice_hours int not null default 24,
  advance_weeks int not null default 4,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table service_categories (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  name text not null, image text, "order" int not null default 0
);

create table vehicle_sizes (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  name text not null, blurb text, image text, "order" int not null default 0
);

create table services (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  category_id uuid references service_categories(id) on delete cascade,
  name text not null,
  description text,
  base_price int not null,
  base_duration_min int not null,
  images text[] not null check (cardinality(images) between 1 and 4),
  "order" int not null default 0,
  is_active boolean not null default true
);

create table service_formulas (
  id uuid primary key default gen_random_uuid(),
  service_id uuid references services(id) on delete cascade,
  name text not null,
  add_price int not null default 0,
  add_duration_min int not null default 0,
  features text[] not null default '{}',
  "order" int not null default 0,
  is_active boolean not null default true
);

create table service_size_modifiers (
  id uuid primary key default gen_random_uuid(),
  service_id uuid references services(id) on delete cascade,
  vehicle_size_id uuid references vehicle_sizes(id) on delete cascade,
  add_price int not null default 0,
  add_duration_min int not null default 0,
  unique(service_id, vehicle_size_id)
);

create table service_addons (
  id uuid primary key default gen_random_uuid(),
  service_id uuid references services(id) on delete cascade,
  name text not null,
  add_price int not null default 0,
  add_duration_min int not null default 0,
  description text,
  "order" int not null default 0,
  is_active boolean not null default true
);

create table opening_hours (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  weekday smallint not null check (weekday between 0 and 6),
  frames jsonb not null -- array of {start:"HH:mm", end:"HH:mm"}
);

create table service_zones (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  city text not null,
  radius_km numeric not null check (radius_km > 0)
);

create table blackout_dates (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  day date not null,
  unique (shop_id, day)
);

create type booking_status as enum ('pending','confirmed','declined','cancelled_by_client','cancelled_by_shop');

create table bookings (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid references shops(id) on delete cascade,
  status booking_status not null default 'pending',
  slot_start timestamptz not null,
  slot_end timestamptz not null,
  client jsonb not null,
  vehicle jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table booking_items (
  id uuid primary key default gen_random_uuid(),
  booking_id uuid references bookings(id) on delete cascade,
  service_id uuid references services(id) on delete cascade,
  formula_id uuid references service_formulas(id) on delete set null,
  size_id uuid references vehicle_sizes(id) on delete set null,
  addon_ids uuid[] not null default '{}',
  unit_price int not null,
  duration_min int not null
);
```

> **RLS**: policy by `owner_user_id` on shops and all children via `shop_id`; public read for published shops & catalog endpoints.

---

# Pricing Calculation (Deterministic)

### Formula

```
Total = Σ items (BaseService + SelectedFormula + SelectedSizeModifier + Σ AddOns)
Duration = Σ items (BaseDuration + FormulaΔ + SizeΔ + Σ AddOnΔ)
```

### TS Contract

```ts
export interface PricingInput {
  services: Array<{
    serviceId: string;
    formulaId?: string;
    sizeId?: string;
    addonIds?: string[];
  }>;
  shopId: string;
}

export interface PricingOutput { totalCents: number; totalDurationMin: number; breakdown: Array<{ serviceId: string; priceCents: number; durationMin: number; lines: string[] }>; }

export async function calculatePricing(input: PricingInput): Promise<PricingOutput> { /* pure, uses DB reads */ }
```

### Display Copy (niche but clear)

* **Vehicle sizes**: "Citadine / Compacte", "Berline / SUV moyen", "SUV / 4x4 grand format", "Utilitaire / Van"
* **Feature bullets** examples: "Aspiration complète habitacle", "Shampoing sièges tissu", "Décontamination chimique jantes", "Traitement céramique express (6 mois)".

---

# Availability & Slotting

### Inputs

* Shop timezone, opening_hours frames
* Booked intervals (confirmed + pending hold window, e.g., 30 min TTL)
* Min notice hours, advance weeks
* Slot step: 15 min (config)
* Requested cumulative duration (from pricing calc)

### Algorithm (pseudocode)

```ts
function generateSlots(shopId, durationMin, fromNow = DateTime.utc()): Slot[] {
  // 1) respect minNotice & advanceWeeks → compute [windowStart, windowEnd]
  // 2) iterate days; skip blackout_dates; get opening frames in shop TZ
  // 3) within each frame, slide by SLOT_STEP; convert to UTC; check fit block [start, start+duration]
  // 4) reject if overlap with any booking interval
  // 5) return up to N slots (paginate)
}
```

### Edge Cases

* Frames crossing midnight → split into two days
* DST changes in shop TZ → use Luxon with IANA zone
* Pending bookings reserve time for 30 minutes to avoid double‑select on high traffic

---

# API Surface (Next.js route handlers)

```
POST   /api/shops                 → create shop
GET    /api/shops/:slug           → public shop profile
PATCH  /api/shops/:id             → update (auth)

GET    /api/shops/:id/categories  → list
POST   /api/categories            → create

GET    /api/shops/:id/sizes       → list
POST   /api/sizes                 → create

GET    /api/shops/:id/services    → list (with formulas/addons/modifiers)
POST   /api/services              → create/update

POST   /api/pricing               → calculate total for a cart
POST   /api/slots                 → get slots for a cart (requires duration)

POST   /api/bookings              → create booking (status=pending)
PATCH  /api/bookings/:id/status   → shop confirm/decline/cancel
```

### Validation

* Zod schemas for all payloads; safe parse; return 422 with issues.

---

# UI/UX Notes (Ultra‑Intuitive)

* **Progress header**: Vehicle → Category → Service(s) → Slot → Details → Confirm
* **Sticky cart** with running price/duration; “Temps total estimé” and “À payer sur place / à la confirmation” (since no payments)
* **Plain language** for detailers; avoid jargon like “SKU”
* **Checklists** for formula features with ✅ icons
* **Mobile‑first**; large tap targets; sane defaults; skeleton loaders
* **Empty states**: helpful copy and 1‑click actions (e.g., “Ajouter votre première catégorie”)

### Microcopy Templates (FR)

* Category card: "Intérieur – Nettoyage habitacle en profondeur"
* Formula labels: "Formule **Confort** (+30€ · +30 min)"
* Add‑on labels: "Dégoudronnage carrosserie (+20€ · +15 min)"
* Slot: "Lun 14:30 – fin 16:00"
* Lead time notice: "Réservation possible au plus tôt dans **{X} h**"

---

# File/Folder Structure (suggested)

```
apps/web
  /app
    /(public)
      /[shopSlug]
        page.tsx            // shop landing + booking wizard
    /api
      /shops
      /services
      /pricing
      /slots
      /bookings
  /components
  /lib (db, zod, pricing, slots)
  /styles
  /tests

packages/db (drizzle/supabase types)
```

---

# Environment & Config

* `NEXT_PUBLIC_SUPABASE_URL`
* `SUPABASE_SERVICE_ROLE`
* `NEXT_PUBLIC_SITE_URL`
* `SLOT_STEP_MIN=15`
* `PENDING_HOLD_MIN=30`

---

# MCP Actions (Cursor)

* **GitHub**

  * Create repo `resaone-detailer-saas`
  * Create PR from `feat/schema-pricing-slots`
  * Protect `main`; require PR checks
* **Supabase**

  * Apply migrations from `/supabase/migrations`
  * Generate typed clients

### Automation Tasks for Cursor

1. Scaffold Next.js (TS, App Router) + Tailwind + shadcn/ui.
2. Add Zod schemas for all API payloads.
3. Implement pricing module + unit tests from fixtures below.
4. Implement slotting module + unit tests for DST/overlap.
5. Build `/[shopSlug]` booking wizard with sticky cart.
6. CRUD dashboards for shop owners (basic).
7. RLS policies + public read views for catalog endpoints.

---

# Test Fixtures (for unit tests)

```ts
// vehicle sizes
const sizes = [
  { id: 's1', name: 'Citadine/Compacte' },
  { id: 's2', name: 'Berline/SUV moyen' },
  { id: 's3', name: 'SUV/4x4 grand format' },
];

// service base
const wash = { id: 'svc1', basePrice: 4000, baseDurationMin: 60 };
const interior = { id: 'svc2', basePrice: 6000, baseDurationMin: 90 };

// formulas
const formulaComfort = { id: 'f1', serviceId: 'svc2', addPrice: 1500, addDurationMin: 20, features: ['Shampoing tapis', 'Plastiques satinés'] };

// size modifiers
const m1 = { serviceId: 'svc1', vehicleSizeId: 's3', addPrice: 1000, addDurationMin: 15 };

// addons
const a1 = { id: 'a1', serviceId: 'svc1', name: 'Décontamination ferreuse', addPrice: 2000, addDurationMin: 20 };
```

---

# Security & Privacy

* RLS: `shops.owner_user_id = auth.uid()`; public `select` only on published catalog views.
* Rate‑limit public APIs; captcha on booking create.
* Do not store payment data (no payments MVP).

---

# Open Questions (flag for founder)

1. Do we allow **multiple staff** (parallel capacity)? If yes, how to model capacity per frame?
2. Should **zones** influence slot availability (e.g., travel buffer)?
3. Booking confirmation: auto‑confirm or manual confirm by default?
4. Required client fields: phone vs email? both?
5. Cancellation windows & policies?
6. Should pending bookings block time immediately (and how long)?

---

# Cursor System Prompt (paste in `.cursor/rules.md` or as conversation preface)

```
You are an expert TypeScript full‑stack engineer. Follow this spec strictly.
- Prefer pure functions, strong typing, Zod validation.
- Produce small, reviewable PRs with tests.
- When uncertain, write TODOs referencing Open Questions.
- Maintain idempotent migrations. Use UTC in DB; convert using shop.timezone at the edge.
- Never invent business rules: use this doc.
```

---

# Acceptance Criteria (MVP demo)

* Can create a shop with hours, sizes, categories, services, formulas, add‑ons.
* Public page at `/{shopSlug}` shows catalog; client can configure multi‑service cart.
* Pricing is correct per fixtures; tests passing.
* Slot API respects min notice & advance window; prevents overlaps; tests passing.
* Booking creates `pending`; owner can `confirm/decline`.
* All copy is FR‑first with niche yet clear terms for detailers.

---

# Next Steps

* Confirm Open Questions
* Decide visual theme & brand (logo/colors)
* Roadmap for payments (Stripe) & staff capacity in v2

globs:
alwaysApply: true
---
